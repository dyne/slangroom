// SPDX-FileCopyrightText: 2024 Dyne.org foundation
//
// SPDX-License-Identifier: AGPL-3.0-or-later

@top Statement {
    ( RuleStatement | ScenarioStatement | RuleStatement | SlangroomStatement | Comment )*
}

Comment {
    comment (newline+ |eof)
}

SlangroomStatement {
    (GtStatement | PcStatement | ThenPrint | GivenHaveStatement | GivenName | WhenStatement | IfEndifStatement |ForEachStatement)
}

// ===== Rule =====
RuleStatement {
    rule (VersionRule | GenericRule) ( newline+ | eof )
}
VersionRule {
    version VersionNumber
}
GenericRule {
    (Identifier | StringLiteral | Keywords)*
}
VersionNumber {
    Number '.'? Number? '.'? Number?
}

// ===== Scenario =====
ScenarioStatement {
    scenario ScenarioType ScenarioComment? ( newline+ | eof )
}
ScenarioType {
    (StringLiteral| Identifier | Keywords)
}
ScenarioComment {
    ":" (Identifier | Keywords | StringLiteral)*
}

@skip {
    space
}

// ===== Zencode Statements =====
GivenHaveStatement {
    given that? I have (a? | my? | the?) valid? StringLiteral named? StringLiteral? (inside | in)?  named? StringLiteral?
    (newline* and I have (a? | my?) valid? StringLiteral named? StringLiteral? (inside | in)? named? StringLiteral?)* ( newline+ | eof )
}
GivenName {
    ((given I am
    (known as)? StringLiteral) |
    (given  I? my name is
    (Identifier | Keywords | StringLiteral)+)) HaveStatement* ( newline+ | eof )
}
HaveStatement{
    newline+ and I have (a? | my?) valid? StringLiteral named? StringLiteral? (inside | in)? named? StringLiteral?
}
WhenStatement {
    when I (Identifier | Keywords | StringLiteral)+ (newline and I (Identifier | Keywords | StringLiteral)+)* (newline+ | eof)
}
IfEndifStatement{
    Condition (IfEndifStatement | WhenStatement | ThenPrint)* endif ( newline+ | eof )
}
Condition {
    if I verify (Identifier | Keywords | StringLiteral)+ ( newline+ | eof )
}
ForEachStatement {
    foreach (StringLiteral | Identifier | Keywords) (in | inside) (StringLiteral | Identifier | Keywords)+  newline+ (ForEachStatement | IfEndifStatement | WhenStatement)*
    endforeach ( newline+ | eof )
}
ThenPrint {
    then I? print (StringLiteral | Identifier | Keywords)+ (newline and +I print (StringLiteral | Identifier | Keywords)+)* ( newline+ | eof )
}

// ===== Slangroom Statements =====
GtStatement {
    (given | then) I
    ({{ GtStatements }})
    ( newline+ | eof )
}
PcStatement {
    (prepare | compute) secret? StringLiteral?':'
    ({{ PcStatements }})
    ( newline+ | eof )
}

// ===== Plugin-Specific Statements =====

{{ Plugin-Specific Statements }}

// ===== Actions =====

Action<term> {
    term
}

SaveAction {
    and output secret? into StringLiteral
}

ActionExecuteSqlStatementWithParameters  {
    Action<execute sql statement WithParameters>
}

WithParameters {
    with parameters
}

// ===== Keywords and Token =====

Keywords {
	version |  unknown | ignore | have | a | my | that | valid | inside | named | am | known | as | connect | to | open | and | send | statement | parameters | record | table | variable | name | address | transaction_id |
	addresses | transaction | sc | path | content | commit | paths | array | values | value | sources | properties | headers | object | json_data | json_schema | request | uri | server_data | client | expires_in |
	token | request_uri | data | my_credentials | email | list_parameters | show_parameters | create_parameters | record_parameters | update_parameters | delete_parameters | send_parameters | url | text | command | jwk |
	holder | fields | verifier_url | issued_vc | disclosed | nonce | sk | script | key | keys | extra | conf | execute | sql | with | read | file | the | of | database | save | ethereum | bytes | balance | suggested |
	gas | price | id | after | broadcast | erc20 | decimals | symbol | total | supply | erc721 | in | owner | asset | download | extract | verbatim | store | list | directory | exists | does | not | exist | verify | git |
	repository | clone | create | new | manipulate | get | set | merge | omit | concat | compact | pick | do | sequential | parallel | same | post | put | patch | validate | json | generate | access | authorization | code |
	details | from | add | start | pb | capacitor | login | ask | password | reset | some | records | one | qr | update | write | into | redis | delete | shell | fetch | local | timestamp | milliseconds | seconds | present | vc |
	sd | jwt | public | pretty | print | zencode | output | is | given | then | when | rule | scenario | if | endif | foreach | endforeach | I
}

@external specialize {Identifier} keywords from "./tokens" {
{{ External-Tokens }}
}

@tokens {
    space { " " | "\t" }
    newline { "\n" | "\r\n" }
    comment { "#" (![\n])*}
    StringLiteral { "'" (![\\\n'] | "\\" _)* "'" }
    symbols { $[a-zA-Z_] | "_" }
    Identifier { symbols+ Number* }
    Number { $[0-9]+ }
}

@external tokens Eoftoken from "./tokens.js" { eof }
